#### code section
	.code

.function "Object init code", 1, 0
Object_init:
	return
.end

.function "Int init code", 1, 0
Int_init:
	return
.end

.function "Bool init code", 1, 0
Bool_init:
	return
.end

.function "String init code", 1, 0
String_init:
	return
.end

.function "IO init code", 1, 0
IO_init:
	return
.end

.function "Main init code", 1, 0
Main_init:
	## store self into the reserved VR0
	VR0	<-	VI0
	call	Object_init
	return
.end

.function "CellularAutomaton init code", 1, 0
CellularAutomaton_init:
	## store self into the reserved VR0
	VR0	<-	VI0
	call	IO_init
	return
.end

.function "Main.main", 1, 1
Main.main:
	## store self and arguments into the reserved VR0..VR0
	VR0	<-	VI0
	## begin assign - line 83
	## begin dispatch - line 83
	## new begin - line 83
	VR1	<-	CellularAutomaton_protObj
	VI0	<-	VR1
	call Object.copy
	VR1	<-	VI0
	call CellularAutomaton_init
	## caller in VR1
	## dispatch to void handling, ends at dispatch_notvoid0
	jumpt	VR1 dispatch_notvoid0
	VR1	<-	str_const0
	VR4	<-	83
	# boxing integer from VR4 to VR3
	VR3	<-	Int_protObj
	VI0	<-	VR3
	call Object.copy
	VR3	<-	VI0
	store	VR4 [VR3, 12]
	# end boxing
	VI0	<-	VR1
	VI1	<-	VR3
	call	_dispatch_abort
dispatch_notvoid0:
	## actual parameter 1
	VR2	<-	str_const4
	## store self and actual parameters into VI's
	VI0	<-	VR1
	VI1	<-	VR2
	## compute the target address
	load	VR2 [VR1, 8]
	load	VR2 [VR2, 28]
	call VR2
	## fetch (and maybe unbox) the result
	VR1	<-	VI0
	## store rhs in VR1 to attribute cells
	store	VR1 [VR0, 12]
	## begin dispatch - line 84
	load	VR1 [VR0, 12]
	## caller in VR1
	## dispatch to void handling, ends at dispatch_notvoid1
	jumpt	VR1 dispatch_notvoid1
	VR1	<-	str_const0
	VR4	<-	84
	# boxing integer from VR4 to VR3
	VR3	<-	Int_protObj
	VI0	<-	VR3
	call Object.copy
	VR3	<-	VI0
	store	VR4 [VR3, 12]
	# end boxing
	VI0	<-	VR1
	VI1	<-	VR3
	call	_dispatch_abort
dispatch_notvoid1:
	## store self and actual parameters into VI's
	VI0	<-	VR1
	## compute the target address
	load	VR2 [VR1, 8]
	load	VR2 [VR2, 32]
	call VR2
	## fetch (and maybe unbox) the result
	VR1	<-	VI0
	## begin let - line 85
	VR2	<-	int_const2.val
	load	VR2 [VR2, 0]
	VR1	<-	VR2
	## let var countdown in VR1
	## begin loop - line 86
loop_start0:
	## < operator - line 86
	## create the result object - not in the original source
	## new begin - line 86
	VR2	<-	Bool_protObj
	VI0	<-	VR2
	call Object.copy
	VR2	<-	VI0
	call Bool_init
	VR3	<-	int_const1.val
	load	VR3 [VR3, 0]
	VR4	<-	VR1
	VR3	<-	VR3	<	VR4
	store	VR3 [VR2, 12]
	## condition in VR2, load effective value into VR3
	load	VR3 [VR2, 12]
	jumpf	VR3 loop_end0
	## begin dispatch - line 88
	load	VR2 [VR0, 12]
	## caller in VR2
	## dispatch to void handling, ends at dispatch_notvoid2
	jumpt	VR2 dispatch_notvoid2
	VR2	<-	str_const0
	VR5	<-	88
	# boxing integer from VR5 to VR4
	VR4	<-	Int_protObj
	VI0	<-	VR4
	call Object.copy
	VR4	<-	VI0
	store	VR5 [VR4, 12]
	# end boxing
	VI0	<-	VR2
	VI1	<-	VR4
	call	_dispatch_abort
dispatch_notvoid2:
	## store self and actual parameters into VI's
	VI0	<-	VR2
	## compute the target address
	load	VR3 [VR2, 8]
	load	VR3 [VR3, 56]
	call VR3
	## fetch (and maybe unbox) the result
	VR2	<-	VI0
	## begin dispatch - line 89
	load	VR2 [VR0, 12]
	## caller in VR2
	## dispatch to void handling, ends at dispatch_notvoid3
	jumpt	VR2 dispatch_notvoid3
	VR2	<-	str_const0
	VR5	<-	89
	# boxing integer from VR5 to VR4
	VR4	<-	Int_protObj
	VI0	<-	VR4
	call Object.copy
	VR4	<-	VI0
	store	VR5 [VR4, 12]
	# end boxing
	VI0	<-	VR2
	VI1	<-	VR4
	call	_dispatch_abort
dispatch_notvoid3:
	## store self and actual parameters into VI's
	VI0	<-	VR2
	## compute the target address
	load	VR3 [VR2, 8]
	load	VR3 [VR3, 32]
	call VR3
	## fetch (and maybe unbox) the result
	VR2	<-	VI0
	## begin assign - line 90
	## - operator - line 90
	VR3	<-	VR1
	VR4	<-	int_const0.val
	load	VR4 [VR4, 0]
	VR3	<-	VR3 - VR4
	VR2	<-	VR3
	## store rhs from VR2 to let var countdown in VR1
	VR1	<-	VR2
	jump	loop_start0
loop_end0:
	## store let result over let var countdown
	VR1	<-	VR2
	VR1	<-	VR0
	## store result into the output register
	VI0	<-	VR1
	return
.end

.function "CellularAutomaton.init", 2, 1
CellularAutomaton.init:
	## store self and arguments into the reserved VR0..VR1
	VR0	<-	VI0
	VR1	<-	VI1
	## begin assign - line 10
	VR2	<-	VR1
	## store rhs in VR2 to attribute population_map
	store	VR2 [VR0, 12]
	VR2	<-	VR0
	## store result into the output register
	VI0	<-	VR2
	return
.end

.function "CellularAutomaton.print", 1, 1
CellularAutomaton.print:
	## store self and arguments into the reserved VR0..VR0
	VR0	<-	VI0
	## begin dispatch - line 17
	VR1	<-	VR0
	## caller in VR1
	## dispatch to void handling, ends at dispatch_notvoid4
	jumpt	VR1 dispatch_notvoid4
	VR1	<-	str_const0
	VR4	<-	17
	# boxing integer from VR4 to VR3
	VR3	<-	Int_protObj
	VI0	<-	VR3
	call Object.copy
	VR3	<-	VI0
	store	VR4 [VR3, 12]
	# end boxing
	VI0	<-	VR1
	VI1	<-	VR3
	call	_dispatch_abort
dispatch_notvoid4:
	## actual parameter 1
	## begin dispatch - line 17
	load	VR2 [VR0, 12]
	## caller in VR2
	## dispatch to void handling, ends at dispatch_notvoid5
	jumpt	VR2 dispatch_notvoid5
	VR2	<-	str_const0
	VR5	<-	17
	# boxing integer from VR5 to VR4
	VR4	<-	Int_protObj
	VI0	<-	VR4
	call Object.copy
	VR4	<-	VI0
	store	VR5 [VR4, 12]
	# end boxing
	VI0	<-	VR2
	VI1	<-	VR4
	call	_dispatch_abort
dispatch_notvoid5:
	## actual parameter 1
	VR3	<-	str_const1
	## store self and actual parameters into VI's
	VI0	<-	VR2
	VI1	<-	VR3
	## compute the target address
	load	VR3 [VR2, 8]
	load	VR3 [VR3, 12]
	call VR3
	## fetch (and maybe unbox) the result
	VR2	<-	VI0
	## store self and actual parameters into VI's
	VI0	<-	VR1
	VI1	<-	VR2
	## compute the target address
	load	VR2 [VR1, 8]
	load	VR2 [VR2, 12]
	call VR2
	## fetch (and maybe unbox) the result
	VR1	<-	VI0
	VR1	<-	VR0
	## store result into the output register
	VI0	<-	VR1
	return
.end

.function "CellularAutomaton.num_cells", 1, 1
CellularAutomaton.num_cells:
	## store self and arguments into the reserved VR0..VR0
	VR0	<-	VI0
	## begin dispatch - line 23
	load	VR1 [VR0, 12]
	## caller in VR1
	## dispatch to void handling, ends at dispatch_notvoid6
	jumpt	VR1 dispatch_notvoid6
	VR1	<-	str_const0
	VR4	<-	23
	# boxing integer from VR4 to VR3
	VR3	<-	Int_protObj
	VI0	<-	VR3
	call Object.copy
	VR3	<-	VI0
	store	VR4 [VR3, 12]
	# end boxing
	VI0	<-	VR1
	VI1	<-	VR3
	call	_dispatch_abort
dispatch_notvoid6:
	## store self and actual parameters into VI's
	VI0	<-	VR1
	## compute the target address
	load	VR2 [VR1, 8]
	load	VR2 [VR2, 16]
	call VR2
	## fetch (and maybe unbox) the result
	VR1	<-	VI0
	# unboxing integer from VR1 to VR2
	load	VR2 [VR1, 12]
	VR1	<-	VR2
	## store result into the output register
	VI0	<-	VR1
	return
.end

.function "CellularAutomaton.cell", 2, 1
CellularAutomaton.cell:
	## store self and arguments into the reserved VR0..VR1
	VR0	<-	VI0
	VR1	<-	VI1
	## begin dispatch - line 27
	load	VR2 [VR0, 12]
	## caller in VR2
	## dispatch to void handling, ends at dispatch_notvoid7
	jumpt	VR2 dispatch_notvoid7
	VR2	<-	str_const0
	VR5	<-	27
	# boxing integer from VR5 to VR4
	VR4	<-	Int_protObj
	VI0	<-	VR4
	call Object.copy
	VR4	<-	VI0
	store	VR5 [VR4, 12]
	# end boxing
	VI0	<-	VR2
	VI1	<-	VR4
	call	_dispatch_abort
dispatch_notvoid7:
	## actual parameter 1
	VR3	<-	VR1
	# boxing integer from VR3 to VR4
	VR4	<-	Int_protObj
	VI0	<-	VR4
	call Object.copy
	VR4	<-	VI0
	store	VR3 [VR4, 12]
	# end boxing
	VR3	<-	VR4
	## actual parameter 2
	VR4	<-	int_const0.val
	load	VR4 [VR4, 0]
	# boxing integer from VR4 to VR5
	VR5	<-	Int_protObj
	VI0	<-	VR5
	call Object.copy
	VR5	<-	VI0
	store	VR4 [VR5, 12]
	# end boxing
	VR4	<-	VR5
	## store self and actual parameters into VI's
	VI0	<-	VR2
	VI1	<-	VR3
	VI2	<-	VR4
	## compute the target address
	load	VR3 [VR2, 8]
	load	VR3 [VR3, 20]
	call VR3
	## fetch (and maybe unbox) the result
	VR2	<-	VI0
	## store result into the output register
	VI0	<-	VR2
	return
.end

.function "CellularAutomaton.cell_left_neighbor", 2, 1
CellularAutomaton.cell_left_neighbor:
	## store self and arguments into the reserved VR0..VR1
	VR0	<-	VI0
	VR1	<-	VI1
	## begin if-then-else - line 31
	## = operator - line 31
	## create the result object - not in the original source
	## new begin - line 31
	VR2	<-	Bool_protObj
	VI0	<-	VR2
	call Object.copy
	VR2	<-	VI0
	call Bool_init
	VR3	<-	VR1
	VR4	<-	int_const1.val
	load	VR4 [VR4, 0]
	VR3	<-	VR3	=	VR4
	store	VR3 [VR2, 12]
	## condition in VR2, load effective value into VR3
	load	VR3 [VR2, 12]
	jumpf	VR3 ite_false0
	## begin true branch
	## begin dispatch - line 32
	VR2	<-	VR0
	## caller in VR2
	## dispatch to void handling, ends at dispatch_notvoid8
	jumpt	VR2 dispatch_notvoid8
	VR2	<-	str_const0
	VR5	<-	32
	# boxing integer from VR5 to VR4
	VR4	<-	Int_protObj
	VI0	<-	VR4
	call Object.copy
	VR4	<-	VI0
	store	VR5 [VR4, 12]
	# end boxing
	VI0	<-	VR2
	VI1	<-	VR4
	call	_dispatch_abort
dispatch_notvoid8:
	## actual parameter 1
	## - operator - line 32
	## begin dispatch - line 32
	VR4	<-	VR0
	## caller in VR4
	## dispatch to void handling, ends at dispatch_notvoid9
	jumpt	VR4 dispatch_notvoid9
	VR4	<-	str_const0
	VR7	<-	32
	# boxing integer from VR7 to VR6
	VR6	<-	Int_protObj
	VI0	<-	VR6
	call Object.copy
	VR6	<-	VI0
	store	VR7 [VR6, 12]
	# end boxing
	VI0	<-	VR4
	VI1	<-	VR6
	call	_dispatch_abort
dispatch_notvoid9:
	## store self and actual parameters into VI's
	VI0	<-	VR4
	## compute the target address
	load	VR5 [VR4, 8]
	load	VR5 [VR5, 36]
	call VR5
	## fetch (and maybe unbox) the result
	VR4	<-	VI0
	VR5	<-	int_const0.val
	load	VR5 [VR5, 0]
	VR4	<-	VR4 - VR5
	VR3	<-	VR4
	## store self and actual parameters into VI's
	VI0	<-	VR2
	VI1	<-	VR3
	## compute the target address
	load	VR3 [VR2, 8]
	load	VR3 [VR3, 40]
	call VR3
	## fetch (and maybe unbox) the result
	VR2	<-	VI0
	jump	ite_end0
	## begin false branch
ite_false0:
	## begin dispatch - line 34
	VR2	<-	VR0
	## caller in VR2
	## dispatch to void handling, ends at dispatch_notvoid10
	jumpt	VR2 dispatch_notvoid10
	VR2	<-	str_const0
	VR5	<-	34
	# boxing integer from VR5 to VR4
	VR4	<-	Int_protObj
	VI0	<-	VR4
	call Object.copy
	VR4	<-	VI0
	store	VR5 [VR4, 12]
	# end boxing
	VI0	<-	VR2
	VI1	<-	VR4
	call	_dispatch_abort
dispatch_notvoid10:
	## actual parameter 1
	## - operator - line 34
	VR4	<-	VR1
	VR5	<-	int_const0.val
	load	VR5 [VR5, 0]
	VR4	<-	VR4 - VR5
	VR3	<-	VR4
	## store self and actual parameters into VI's
	VI0	<-	VR2
	VI1	<-	VR3
	## compute the target address
	load	VR3 [VR2, 8]
	load	VR3 [VR3, 40]
	call VR3
	## fetch (and maybe unbox) the result
	VR2	<-	VI0
ite_end0:
	## store result into the output register
	VI0	<-	VR2
	return
.end

.function "CellularAutomaton.cell_right_neighbor", 2, 1
CellularAutomaton.cell_right_neighbor:
	## store self and arguments into the reserved VR0..VR1
	VR0	<-	VI0
	VR1	<-	VI1
	## begin if-then-else - line 39
	## = operator - line 39
	## create the result object - not in the original source
	## new begin - line 39
	VR2	<-	Bool_protObj
	VI0	<-	VR2
	call Object.copy
	VR2	<-	VI0
	call Bool_init
	VR3	<-	VR1
	## - operator - line 39
	## begin dispatch - line 39
	VR5	<-	VR0
	## caller in VR5
	## dispatch to void handling, ends at dispatch_notvoid11
	jumpt	VR5 dispatch_notvoid11
	VR5	<-	str_const0
	VR8	<-	39
	# boxing integer from VR8 to VR7
	VR7	<-	Int_protObj
	VI0	<-	VR7
	call Object.copy
	VR7	<-	VI0
	store	VR8 [VR7, 12]
	# end boxing
	VI0	<-	VR5
	VI1	<-	VR7
	call	_dispatch_abort
dispatch_notvoid11:
	## store self and actual parameters into VI's
	VI0	<-	VR5
	## compute the target address
	load	VR6 [VR5, 8]
	load	VR6 [VR6, 36]
	call VR6
	## fetch (and maybe unbox) the result
	VR5	<-	VI0
	VR6	<-	int_const0.val
	load	VR6 [VR6, 0]
	VR5	<-	VR5 - VR6
	VR4	<-	VR5
	VR3	<-	VR3	=	VR4
	store	VR3 [VR2, 12]
	## condition in VR2, load effective value into VR3
	load	VR3 [VR2, 12]
	jumpf	VR3 ite_false1
	## begin true branch
	## begin dispatch - line 40
	VR2	<-	VR0
	## caller in VR2
	## dispatch to void handling, ends at dispatch_notvoid12
	jumpt	VR2 dispatch_notvoid12
	VR2	<-	str_const0
	VR5	<-	40
	# boxing integer from VR5 to VR4
	VR4	<-	Int_protObj
	VI0	<-	VR4
	call Object.copy
	VR4	<-	VI0
	store	VR5 [VR4, 12]
	# end boxing
	VI0	<-	VR2
	VI1	<-	VR4
	call	_dispatch_abort
dispatch_notvoid12:
	## actual parameter 1
	VR3	<-	int_const1.val
	load	VR3 [VR3, 0]
	## store self and actual parameters into VI's
	VI0	<-	VR2
	VI1	<-	VR3
	## compute the target address
	load	VR3 [VR2, 8]
	load	VR3 [VR3, 40]
	call VR3
	## fetch (and maybe unbox) the result
	VR2	<-	VI0
	jump	ite_end1
	## begin false branch
ite_false1:
	## begin dispatch - line 42
	VR2	<-	VR0
	## caller in VR2
	## dispatch to void handling, ends at dispatch_notvoid13
	jumpt	VR2 dispatch_notvoid13
	VR2	<-	str_const0
	VR5	<-	42
	# boxing integer from VR5 to VR4
	VR4	<-	Int_protObj
	VI0	<-	VR4
	call Object.copy
	VR4	<-	VI0
	store	VR5 [VR4, 12]
	# end boxing
	VI0	<-	VR2
	VI1	<-	VR4
	call	_dispatch_abort
dispatch_notvoid13:
	## actual parameter 1
	## + operator - line 42
	VR4	<-	VR1
	VR5	<-	int_const0.val
	load	VR5 [VR5, 0]
	VR4	<-	VR4 + VR5
	VR3	<-	VR4
	## store self and actual parameters into VI's
	VI0	<-	VR2
	VI1	<-	VR3
	## compute the target address
	load	VR3 [VR2, 8]
	load	VR3 [VR3, 40]
	call VR3
	## fetch (and maybe unbox) the result
	VR2	<-	VI0
ite_end1:
	## store result into the output register
	VI0	<-	VR2
	return
.end

.function "CellularAutomaton.cell_at_next_evolution", 2, 1
CellularAutomaton.cell_at_next_evolution:
	## store self and arguments into the reserved VR0..VR1
	VR0	<-	VI0
	VR1	<-	VI1
	## begin if-then-else - line 52
	## = operator - line 52
	## create the result object - not in the original source
	## new begin - line 52
	VR2	<-	Bool_protObj
	VI0	<-	VR2
	call Object.copy
	VR2	<-	VI0
	call Bool_init
	## + operator - line 51
	## + operator - line 50
	## begin if-then-else - line 49
	## = operator - line 49
	## begin dispatch - line 49
	VR6	<-	VR0
	## caller in VR6
	## dispatch to void handling, ends at dispatch_notvoid14
	jumpt	VR6 dispatch_notvoid14
	VR6	<-	str_const0
	VR9	<-	49
	# boxing integer from VR9 to VR8
	VR8	<-	Int_protObj
	VI0	<-	VR8
	call Object.copy
	VR8	<-	VI0
	store	VR9 [VR8, 12]
	# end boxing
	VI0	<-	VR6
	VI1	<-	VR8
	call	_dispatch_abort
dispatch_notvoid14:
	## actual parameter 1
	VR7	<-	VR1
	## store self and actual parameters into VI's
	VI0	<-	VR6
	VI1	<-	VR7
	## compute the target address
	load	VR7 [VR6, 8]
	load	VR7 [VR7, 40]
	call VR7
	## fetch (and maybe unbox) the result
	VR6	<-	VI0
	VR7	<-	str_const2
	VR8	<-	bool_const1
	VI0	<-	VR8
	VR8	<-	bool_const0
	VI1	<-	VR8
	VI2	<-	VR6
	VI3	<-	VR7
	call equality_test
	VR5	<-	VI0
	## condition in VR5, load effective value into VR6
	load	VR6 [VR5, 12]
	jumpf	VR6 ite_false2
	## begin true branch
	VR5	<-	int_const0.val
	load	VR5 [VR5, 0]
	jump	ite_end2
	## begin false branch
ite_false2:
	VR5	<-	int_const1.val
	load	VR5 [VR5, 0]
ite_end2:
	## begin if-then-else - line 50
	## = operator - line 50
	## begin dispatch - line 50
	VR7	<-	VR0
	## caller in VR7
	## dispatch to void handling, ends at dispatch_notvoid15
	jumpt	VR7 dispatch_notvoid15
	VR7	<-	str_const0
	VR10	<-	50
	# boxing integer from VR10 to VR9
	VR9	<-	Int_protObj
	VI0	<-	VR9
	call Object.copy
	VR9	<-	VI0
	store	VR10 [VR9, 12]
	# end boxing
	VI0	<-	VR7
	VI1	<-	VR9
	call	_dispatch_abort
dispatch_notvoid15:
	## actual parameter 1
	VR8	<-	VR1
	## store self and actual parameters into VI's
	VI0	<-	VR7
	VI1	<-	VR8
	## compute the target address
	load	VR8 [VR7, 8]
	load	VR8 [VR8, 44]
	call VR8
	## fetch (and maybe unbox) the result
	VR7	<-	VI0
	VR8	<-	str_const2
	VR9	<-	bool_const1
	VI0	<-	VR9
	VR9	<-	bool_const0
	VI1	<-	VR9
	VI2	<-	VR7
	VI3	<-	VR8
	call equality_test
	VR6	<-	VI0
	## condition in VR6, load effective value into VR7
	load	VR7 [VR6, 12]
	jumpf	VR7 ite_false3
	## begin true branch
	VR6	<-	int_const0.val
	load	VR6 [VR6, 0]
	jump	ite_end3
	## begin false branch
ite_false3:
	VR6	<-	int_const1.val
	load	VR6 [VR6, 0]
ite_end3:
	VR5	<-	VR5 + VR6
	VR4	<-	VR5
	## begin if-then-else - line 51
	## = operator - line 51
	## begin dispatch - line 51
	VR6	<-	VR0
	## caller in VR6
	## dispatch to void handling, ends at dispatch_notvoid16
	jumpt	VR6 dispatch_notvoid16
	VR6	<-	str_const0
	VR9	<-	51
	# boxing integer from VR9 to VR8
	VR8	<-	Int_protObj
	VI0	<-	VR8
	call Object.copy
	VR8	<-	VI0
	store	VR9 [VR8, 12]
	# end boxing
	VI0	<-	VR6
	VI1	<-	VR8
	call	_dispatch_abort
dispatch_notvoid16:
	## actual parameter 1
	VR7	<-	VR1
	## store self and actual parameters into VI's
	VI0	<-	VR6
	VI1	<-	VR7
	## compute the target address
	load	VR7 [VR6, 8]
	load	VR7 [VR7, 48]
	call VR7
	## fetch (and maybe unbox) the result
	VR6	<-	VI0
	VR7	<-	str_const2
	VR8	<-	bool_const1
	VI0	<-	VR8
	VR8	<-	bool_const0
	VI1	<-	VR8
	VI2	<-	VR6
	VI3	<-	VR7
	call equality_test
	VR5	<-	VI0
	## condition in VR5, load effective value into VR6
	load	VR6 [VR5, 12]
	jumpf	VR6 ite_false4
	## begin true branch
	VR5	<-	int_const0.val
	load	VR5 [VR5, 0]
	jump	ite_end4
	## begin false branch
ite_false4:
	VR5	<-	int_const1.val
	load	VR5 [VR5, 0]
ite_end4:
	VR4	<-	VR4 + VR5
	VR3	<-	VR4
	VR4	<-	int_const0.val
	load	VR4 [VR4, 0]
	VR3	<-	VR3	=	VR4
	store	VR3 [VR2, 12]
	## condition in VR2, load effective value into VR3
	load	VR3 [VR2, 12]
	jumpf	VR3 ite_false5
	## begin true branch
	VR2	<-	str_const2
	jump	ite_end5
	## begin false branch
ite_false5:
	VR2	<-	str_const3
ite_end5:
	## store result into the output register
	VI0	<-	VR2
	return
.end

.function "CellularAutomaton.evolve", 1, 1
CellularAutomaton.evolve:
	## store self and arguments into the reserved VR0..VR0
	VR0	<-	VI0
	## begin let - line 61
	VR1	<-	0
	## let var position in VR1
	## begin let - line 62
	## begin dispatch - line 62
	VR3	<-	VR0
	## caller in VR3
	## dispatch to void handling, ends at dispatch_notvoid17
	jumpt	VR3 dispatch_notvoid17
	VR3	<-	str_const0
	VR6	<-	62
	# boxing integer from VR6 to VR5
	VR5	<-	Int_protObj
	VI0	<-	VR5
	call Object.copy
	VR5	<-	VI0
	store	VR6 [VR5, 12]
	# end boxing
	VI0	<-	VR3
	VI1	<-	VR5
	call	_dispatch_abort
dispatch_notvoid17:
	## store self and actual parameters into VI's
	VI0	<-	VR3
	## compute the target address
	load	VR4 [VR3, 8]
	load	VR4 [VR4, 36]
	call VR4
	## fetch (and maybe unbox) the result
	VR3	<-	VI0
	VR2	<-	VR3
	## let var num in VR2
	## begin let - line 63
	## create a let variable - not in the original source
	## new begin - line 63
	VR3	<-	String_protObj
	VI0	<-	VR3
	call Object.copy
	VR3	<-	VI0
	call String_init
	## let var temp in VR3
	## begin loop - line 65
loop_start1:
	## < operator - line 65
	## create the result object - not in the original source
	## new begin - line 65
	VR4	<-	Bool_protObj
	VI0	<-	VR4
	call Object.copy
	VR4	<-	VI0
	call Bool_init
	VR5	<-	VR1
	VR6	<-	VR2
	VR5	<-	VR5	<	VR6
	store	VR5 [VR4, 12]
	## condition in VR4, load effective value into VR5
	load	VR5 [VR4, 12]
	jumpf	VR5 loop_end1
	## begin assign - line 67
	## begin dispatch - line 67
	VR4	<-	VR3
	## caller in VR4
	## dispatch to void handling, ends at dispatch_notvoid18
	jumpt	VR4 dispatch_notvoid18
	VR4	<-	str_const0
	VR7	<-	67
	# boxing integer from VR7 to VR6
	VR6	<-	Int_protObj
	VI0	<-	VR6
	call Object.copy
	VR6	<-	VI0
	store	VR7 [VR6, 12]
	# end boxing
	VI0	<-	VR4
	VI1	<-	VR6
	call	_dispatch_abort
dispatch_notvoid18:
	## actual parameter 1
	## begin dispatch - line 67
	VR5	<-	VR0
	## caller in VR5
	## dispatch to void handling, ends at dispatch_notvoid19
	jumpt	VR5 dispatch_notvoid19
	VR5	<-	str_const0
	VR8	<-	67
	# boxing integer from VR8 to VR7
	VR7	<-	Int_protObj
	VI0	<-	VR7
	call Object.copy
	VR7	<-	VI0
	store	VR8 [VR7, 12]
	# end boxing
	VI0	<-	VR5
	VI1	<-	VR7
	call	_dispatch_abort
dispatch_notvoid19:
	## actual parameter 1
	VR6	<-	VR1
	## store self and actual parameters into VI's
	VI0	<-	VR5
	VI1	<-	VR6
	## compute the target address
	load	VR6 [VR5, 8]
	load	VR6 [VR6, 52]
	call VR6
	## fetch (and maybe unbox) the result
	VR5	<-	VI0
	## store self and actual parameters into VI's
	VI0	<-	VR4
	VI1	<-	VR5
	## compute the target address
	load	VR5 [VR4, 8]
	load	VR5 [VR5, 12]
	call VR5
	## fetch (and maybe unbox) the result
	VR4	<-	VI0
	## store rhs from VR4 to let var temp in VR3
	VR3	<-	VR4
	## begin assign - line 68
	## + operator - line 68
	VR5	<-	VR1
	VR6	<-	int_const0.val
	load	VR6 [VR6, 0]
	VR5	<-	VR5 + VR6
	VR4	<-	VR5
	## store rhs from VR4 to let var position in VR1
	VR1	<-	VR4
	jump	loop_start1
loop_end1:
	## begin assign - line 71
	VR4	<-	VR3
	## store rhs in VR4 to attribute population_map
	store	VR4 [VR0, 12]
	VR4	<-	VR0
	## store let result over let var temp
	VR3	<-	VR4
	## store let result over let var num
	VR2	<-	VR3
	## store let result over let var position
	VR1	<-	VR2
	## store result into the output register
	VI0	<-	VR1
	return
.end

#### data section
	.data
#### object tags
_int_tag:
	DW	1
_bool_tag:
	DW	2
_string_tag:
	DW	3
_Object_tag:
	DW	0
_IO_tag:
	DW	4
_Main_tag:
	DW	5
_CellularAutomaton_tag:
	DW	6
#### constants
str_const16:
	DW	3
	DW	5
	DL	String_dispatch
	DL	int_const1
	DB	0	
str_const15:
	DW	3
	DW	6
	DL	String_dispatch
	DL	int_const3
	DB	"Main"
	DB	0	
str_const14:
	DW	3
	DW	9
	DL	String_dispatch
	DL	int_const4
	DB	"CellularAutomaton"
	DB	0	
str_const13:
	DW	3
	DW	5
	DL	String_dispatch
	DL	int_const5
	DB	"IO"
	DB	0	
str_const12:
	DW	3
	DW	6
	DL	String_dispatch
	DL	int_const6
	DB	"String"
	DB	0	
str_const11:
	DW	3
	DW	6
	DL	String_dispatch
	DL	int_const3
	DB	"Bool"
	DB	0	
str_const10:
	DW	3
	DW	5
	DL	String_dispatch
	DL	int_const7
	DB	"Int"
	DB	0	
str_const9:
	DW	3
	DW	6
	DL	String_dispatch
	DL	int_const6
	DB	"Object"
	DB	0	
str_const8:
	DW	3
	DW	7
	DL	String_dispatch
	DL	int_const8
	DB	"_prim_slot"
	DB	0	
str_const7:
	DW	3
	DW	7
	DL	String_dispatch
	DL	int_const9
	DB	"SELF_TYPE"
	DB	0	
str_const6:
	DW	3
	DW	7
	DL	String_dispatch
	DL	int_const9
	DB	"_no_class"
	DB	0	
str_const5:
	DW	3
	DW	8
	DL	String_dispatch
	DL	int_const10
	DB	"<basic class>"
	DB	0	
str_const4:
	DW	3
	DW	9
	DL	String_dispatch
	DL	int_const11
	DB	"         X         "
	DB	0	
str_const3:
	DW	3
	DW	5
	DL	String_dispatch
	DL	int_const0
	DB	"."
	DB	0	
str_const2:
	DW	3
	DW	5
	DL	String_dispatch
	DL	int_const0
	DB	"X"
	DB	0	
str_const1:
	DW	3
	DW	5
	DL	String_dispatch
	DL	int_const0
	DB	"\n"
	DB	0	
str_const0:
	DW	3
	DW	11
	DL	String_dispatch
	DL	int_const12
	DB	"_tests/advanced/cells.cl"
	DB	0	
int_const12:
	DW	1
	DW	4
	DL	Object_dispatch
int_const12.val:
	DW	24
int_const11:
	DW	1
	DW	4
	DL	Object_dispatch
int_const11.val:
	DW	19
int_const10:
	DW	1
	DW	4
	DL	Object_dispatch
int_const10.val:
	DW	13
int_const9:
	DW	1
	DW	4
	DL	Object_dispatch
int_const9.val:
	DW	9
int_const8:
	DW	1
	DW	4
	DL	Object_dispatch
int_const8.val:
	DW	10
int_const7:
	DW	1
	DW	4
	DL	Object_dispatch
int_const7.val:
	DW	3
int_const6:
	DW	1
	DW	4
	DL	Object_dispatch
int_const6.val:
	DW	6
int_const5:
	DW	1
	DW	4
	DL	Object_dispatch
int_const5.val:
	DW	2
int_const4:
	DW	1
	DW	4
	DL	Object_dispatch
int_const4.val:
	DW	17
int_const3:
	DW	1
	DW	4
	DL	Object_dispatch
int_const3.val:
	DW	4
int_const2:
	DW	1
	DW	4
	DL	Object_dispatch
int_const2.val:
	DW	20
int_const1:
	DW	1
	DW	4
	DL	Object_dispatch
int_const1.val:
	DW	0
int_const0:
	DW	1
	DW	4
	DL	Object_dispatch
int_const0.val:
	DW	1
bool_const1:
	DW	2
	DW	4
	DL	Object_dispatch
	DW	1
#### class names by tag
class_nameTab:
	DL	str_const9
	DL	str_const10
	DL	str_const11
	DL	str_const12
	DL	str_const13
	DL	str_const15
	DL	str_const14
#### prototypes and init my tag
class_objTab:
	DL	Object_protObj
	DL	Object_init
	DL	Int_protObj
	DL	Int_init
	DL	Bool_protObj
	DL	Bool_init
	DL	String_protObj
	DL	String_init
	DL	IO_protObj
	DL	IO_init
	DL	Main_protObj
	DL	Main_init
	DL	CellularAutomaton_protObj
	DL	CellularAutomaton_init
#### dispatch tables by tag
Bool_dispatch:
	DL	Object.abort
	DL	Object.copy
	DL	Object.type_name
IO_dispatch:
	DL	Object.abort
	DL	Object.copy
	DL	Object.type_name
	DL	IO.out_string
	DL	IO.out_int
	DL	IO.in_string
	DL	IO.in_int
Main_dispatch:
	DL	Object.abort
	DL	Object.copy
	DL	Object.type_name
	DL	Main.main
CellularAutomaton_dispatch:
	DL	Object.abort
	DL	Object.copy
	DL	Object.type_name
	DL	IO.out_string
	DL	IO.out_int
	DL	IO.in_string
	DL	IO.in_int
	DL	CellularAutomaton.init
	DL	CellularAutomaton.print
	DL	CellularAutomaton.num_cells
	DL	CellularAutomaton.cell
	DL	CellularAutomaton.cell_left_neighbor
	DL	CellularAutomaton.cell_right_neighbor
	DL	CellularAutomaton.cell_at_next_evolution
	DL	CellularAutomaton.evolve
#### prototype objects
Object_protObj:
	DW	0
	DW	3
	DL	Object_dispatch
Bool_protObj:
	DW	2
	DW	4
	DL	Bool_dispatch
	DW	0
IO_protObj:
	DW	4
	DW	3
	DL	IO_dispatch
Main_protObj:
	DW	5
	DW	4
	DL	Main_dispatch
	DW	0
CellularAutomaton_protObj:
	DW	6
	DW	4
	DL	CellularAutomaton_dispatch
	DL	str_const16
